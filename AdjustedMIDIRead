import json
import os
import sys

import mido
from mido import MidiFile

# ─────────────────────────────────────────────
# Paths  (all relative to this script's folder)
# ─────────────────────────────────────────────
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
MIDI_FOLDER = os.path.join(SCRIPT_DIR, "midi_files")
OUTPUT_FOLDER = os.path.join(SCRIPT_DIR, "arduino_output")
OUTPUT_FILE = os.path.join(OUTPUT_FOLDER, "actuator_events.json")

# ─────────────────────────────────────────────
# 61-key config
# ─────────────────────────────────────────────
NUM_KEYS = 61
LOWEST_MIDI_NOTE = 36                              # C2
HIGHEST_MIDI_NOTE = LOWEST_MIDI_NOTE + NUM_KEYS - 1  # C7


# ─────────────────────────────────────────────
# STEP 1 & 2 — list midi_files/ and let user pick
# ─────────────────────────────────────────────
def pick_midi_file() -> str:
    """
    Scans midi_files/ and returns the full path to the chosen .mid file.
    The user can type either the number shown or the song name (partial match OK).
    """
    os.makedirs(MIDI_FOLDER, exist_ok=True)

    midi_files = sorted(
        f for f in os.listdir(MIDI_FOLDER) if f.lower().endswith(".mid")
    )

    if not midi_files:
        print(f"\n No .mid files found in '{MIDI_FOLDER}'.")
        print("Drop some MIDI files there and run the script again.")
        sys.exit(1)

    print("\n Available songs:")
    for i, name in enumerate(midi_files, start=1):
        print(f"   {i:>2}. {name}")

    print()
    raw = input("Enter song number or name: ").strip()

    # Try numeric selection first
    if raw.isdigit():
        idx = int(raw) - 1
        if 0 <= idx < len(midi_files):
            chosen = midi_files[idx]
        else:
            print(f" '{raw}' is out of range.")
            sys.exit(1)
    else:
        # Partial, case-insensitive name match
        matches = [f for f in midi_files if raw.lower() in f.lower()]
        if len(matches) == 1:
            chosen = matches[0]
        elif len(matches) > 1:
            print(f"  Ambiguous — '{raw}' matches: {matches}")
            sys.exit(1)
        else:
            print(f"  No song matching '{raw}' found.")
            sys.exit(1)

    full_path = os.path.join(MIDI_FOLDER, chosen)
    print(f"\n  Selected: {chosen}")
    return full_path


# ─────────────────────────────────────────────
# STEP 3 — parse MIDI into actuator events
# ─────────────────────────────────────────────
def parse_midi(midi_path: str) -> list:
    mid = MidiFile(midi_path)

    print(f"\nType              : {mid.type}")
    print(f"Ticks per beat    : {mid.ticks_per_beat}")
    print(f"Tracks            : {len(mid.tracks)}")
    print(f"61-key range      : MIDI {LOWEST_MIDI_NOTE}..{HIGHEST_MIDI_NOTE}  "
          f"(key index 0..{NUM_KEYS-1})")

    merged = mido.merge_tracks(mid.tracks)
    tempo = 500_000  # 120 BPM default
    t_sec = 0.0
    active: dict = {}
    events: list = []

    for msg in merged:
        if msg.time:
            t_sec += mido.tick2second(msg.time, mid.ticks_per_beat, tempo)

        if msg.type == "set_tempo":
            tempo = msg.tempo
            continue

        is_on  = msg.type == "note_on"  and msg.velocity > 0
        is_off = msg.type == "note_off" or (
                 msg.type == "note_on"  and msg.velocity == 0)

        note = getattr(msg, "note", None)
        if note is None:
            continue
        if note < LOWEST_MIDI_NOTE or note > HIGHEST_MIDI_NOTE:
            continue

        key = (msg.channel, note)

        if is_on:
            active.setdefault(key, []).append((t_sec, int(msg.velocity)))

        elif is_off and key in active and active[key]:
            start_t, start_vel = active[key].pop()
            dur_sec = max(0.0, t_sec - start_t)
            key_index = note - LOWEST_MIDI_NOTE

            events.append({
                "t_ms":     int(round(start_t  * 1000)),
                "key":      int(key_index),
                "vel":      int(start_vel),
                "dur_ms":   int(round(dur_sec  * 1000)),
                "channel":  int(msg.channel),
                "midi_note": int(note),
            })

    events.sort(key=lambda e: e["t_ms"])
    return events


# ─────────────────────────────────────────────
# STEP 4 — export to arduino_output/
# ─────────────────────────────────────────────
def export_events(events: list) -> None:
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)
    with open(OUTPUT_FILE, "w") as f:
        json.dump(events, f, indent=2)
    print(f"\n  Wrote {len(events)} events → {OUTPUT_FILE}")
    print("    Copy your Arduino .ino sketch into the same folder,")
    print("    then upload it and open Serial Monitor at 115200 baud.")


# ─────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────
def main():
    midi_path = pick_midi_file()
    events    = parse_midi(midi_path)

    print(f"\nBuilt {len(events)} actuator events.")
    print("First 10:")
    for e in events[:10]:
        print(e)

    export_events(events)


if __name__ == "__main__":
    main()